---
title: 
author: codongmin
date: 
categories: 
tags: 
preview:
---

- 개요 - 들어가며
    - [x] 전략 패턴이 필요한 순간들? 을 앞에서 짚어주는 것?
    - 적용할 만한 상황들을 물음으로 던지는 것
- 전략 패턴의 구성
    - [x] 전략 패턴의 개념 설명
    - 구성 설명
        - [x] 전략 패턴의 도식도 필요
- 전략 패턴의 구현 방법
    - 어떻게 구현하는지 ?
        - [ ] 생성자 구현 방식
        - [x] 파라미터로 넘겨주는 방식
            - **행동 파라미터화** 내용이 같이 들어가도 좋을 듯(모던 자바 인 액션, 행동 파라미터화 예시)
- 전략 패턴의 사용 예시 & 샘플 적용
    - 어떤 예시가 좋을까 ?
    - 실 생활 예시 ?
        - 게임
        - 자바에서 사용되는 패턴들
        - 스프링에서 사용되는 패턴들
- 마무리하며
    - 앞에서 언급한 내용 정리

---
## 0. 들어가며

우리는 많은 실생활 속에서 수많은 전략 패턴들을 경험하며 살아가고 있다. 여러 선택지들과 선택지에 따라 서로 다른 행동들을 해야하는 경우를 심심치 않게 발견한다. 예를 들어 하나의 상품을 구매하고 결제하는데에도 신용카드를 통해 결제하거나, 페이팔을 통해 결제하거나, 포인트를 통해 결제할 수 있다. 이는 구매할 상품을 결제하는 행위는 동일하지만, 세부적으로 결제하는 방법에 차이가 있기 때문에 나타나는 현상이다.

_(여기 하나 더 추가됐으면 좋겠다)_

디자인 패턴은 현실의 문제들을 프로그래밍으로 풀어내면서 자주 발생하는 문제들을 해결하기 위해 고안된 일종의 노하우다. 노하우의 테크닉을 알아가는 것도 중요하지만, 본질적으로 어떤 문제들이 자주 발생했는지를 느껴보는 것이 중요하다. 오늘 다룰 전략패턴은 어떤 문제들로부터 탄생했는지 알아보고, 이를 어떻게 풀이해나가는지를 살펴보려고 한다.

전략 패턴의 시작은 책임을 분리하는 것에서부터 시작한다.

## 1. 기존 문제
~~여기서부터 선택지에 따른 적절한 절차를 ‘전략’이라고 칭한다.~~

여러 선택지에 따른 각기 다른 행동을 처리하는 방법으로 가장 러프하게 생각해볼 수 있는 방법은 if-else 문을 활용한 분기처리이다. 가장 직관적이고 기본적인 방법이다. 다음과 같이 작성할 수 있다.

```java
if (선택지 1) {
	행동 1
} else if (선택지 2) {
	행동 2
} else if (선택지 3) {
	행동 3
}
```

사실 선택지가 제한되어 있고, 그에 따른 분기처리가 간단하다면 위 코드는 매우 적합한 코드가 될 수 있을 것 같다. 직관적이고 이해하기 쉽다. 하지만 서비스가 발전하고 시스템이 복잡해지는 경우 혼란스워진다.된다.

다음 코드를 보자

_(복잡한 수도 코드)_

## 해결
위 문제를 다음과 같이 해결해볼 수 있다. 



두 패턴의 차이점이 발생하게 되는 이유는 전자의 경우 두 가지의 행동 맥락(책임)이 공존하기 때문이다.

### 전략 패턴의 개념과 구조

### 개념

(이미지)

기존 문제에서 다룬 코드에는 2개의 행동 맥락(앞으로는 '책임'이라고 부른다.)이 공존하고 있다.

1. 선택지에 따라 행동을 ‘선택’ 하는 책임.
2. 선택된 행동을 ‘수행’해야하는 책임.

전략패턴에서는 위의 두 책임을 다음과 같이 표현한다. 

행동을 선택하는 책임을 갖는 대상을 **컨텍스트(Context)** 라고 부른다. 
선택된 행동을 '수행' 해야하는 실질적인 책임을 갖는 대상을 **구현 전략(Concrete Strategy)** 라고 부른다. 
추가로 **구현 전략** 안에서 실제로 구체적인 '수행 방법'을 담당하는 부분을 **알고리즘(Algorithm)** 이라 표현한다.

그리고 이러한 **구현 전략**들은 각각의 **알고리즘**을 **캡슐화**하고 있는 형태를 가지고 있다.

공동된 구현 전략들끼리 인터페이스로 추출한 것을 **전략(Strategy)** 라고 표현한다.

### 구조

개념에서 언급한 **전략 패턴**의 각 **요소**들의 **관계**를 그림으로 표현하면 다음과 같다. 
![[Pasted image 20240906215230.png]]
Context부터 확인해보자 , 여기서 중요한 것은 컨택스트가 전략을 인터페이스 형태로 참조하고 있다는 사실이다. 
전략이 인터페이스 형태이기 때문에 다형성을 활용하여 상황에 맞는 상호 교환 가능한 전략들로 대체가 가능하다. 

상호 교환 가능한 전략들은 구현 전략들을 Concrete Strategy들을 의미한다.
각각의 구현전략들이 서로 다른 알고리즘을 서로 캡슐화하고 있기 때문에, 


## 전략 패턴의 구현 방법

### 생성자 활용 
생성자를 활용하여 생성시에 구체 전략을 넘겨주는 방법 


### 인자값 활용 
특정한 메서드를 실행할 때, **인수 값(argument)** 으로 **특정한 동작**을 넘겨주는 방법이 있다. 

이러한 방식을 **동작 파라미터화(behavior parameterization)** 라고 부른다. 동작 파라미터화는 특정한 동작을 수행하는 코드블럭이다. 이 코드블럭은 바로 실행되는 것이 아닌 메서드 내에서 호출되게 된다. 어떤 코드블럭을 넘겨주는냐에 따라서, 메서드의 동작이 결정된다. 

동작 파라미터화 기법을 통해 우리가 원하는 동작을 메서드의 인수로 전달함으로써 요구사항에 유연하게 대처할 수 있다는 점과, 하나의 메서드로 다양한 동작을 수행할 수 있게 재활용이 가능하다는 장점을 가질 수 있다. 이는 전략패턴에서도 동일한 이점을 가져다 줄 수 있다.

다음 예시 상황을 살펴보자

> **텍스트 입력을 검증하는 검증 상황** 

경우에 따라서 입력으로 주어진 텍스트가 **모두 소문자**인지 검증해야하는 상황이 생긴다고 가정해보자. 
전략패턴 도입 전에는 다음과 같이 처리할 수 있을 것이다. 

```java
public boolean validate(String text) {
	return text.matches("[a-z+]");
}
```

그런데 만약, 중간에 **"straetgy"** 단어가 포함되어야 하는 경우나, 입력으로 주어진 텍스트에 **숫자가 포함되어 있는지** 혹은 비지니스 목적에 맞는 검증 로직이 계속 추가된다면 어떻게 될까. 아마 다음 코드처럼 한 없이 길어질지도 모른다. 

```java
public boolean validate(String text) {
	return text.matches("[a-z+]") 
			& text.contains("straetgy")
			& ... 
			& ... ; 
}
```

이때, "straetgy" 를 **"strategy"** 로 변경해야하는 요구사항이 발생하거나, 새로운 검증 조건을 추가해야하는 상황이 오게 되면, validate 메서드가 존재하는 클래스의 코드를 직접적으로 수정해야하는 일이 불가피하게 발생하게 된다. 
- 
- 코드를 읽는 것이 어려워지고
- ocp 위배
- srp




## 마무리하며
