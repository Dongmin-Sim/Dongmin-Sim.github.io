---
title: equals, hashcode를 왜 재정의해야 하나요?
author: codongmin
date: 2024-11-12T19:04:00
categories: 
tags: 
preview: 
image:
  path: /assets/img/thumbnail/why-do-we-have-to-override-equals-and-hashcode-thumbnail.png
  lqip: 
  alt: equals, hashcode를 왜 재정의해야 하나요?
---

## **들어가며**

프로젝트를 진행하면서 도메인 객체의 `equals()` 와 `hashcode()`를 **습관적으로만 재정의해서 사용**하곤 했는데, 이번 글을 통해 `equals()` 와 `hashcode()`과의 관계와 왜 이 둘을 재정의해야만 하는지에 대해서 알아보려고 한다.

`equals()` 와 `hashcode()`를 오버라이드 해야하는 이유과 두 메서드 간의 관계를 명확히 알고있지 않거나, 나처럼 원리와 이유를 모른채 습관적으로만 오버라이드를 했던 경험이 있다면 본 글에서 관련 개념을 익히는데 도움이 될 수 있다. 

반면에 이 글의 대상이 아닌 독자는 다음과 같다. 
- `equals()`와 `hashcode()` 메서드에 대한 기본적인 이해와 두 메서드 간의 관계를 잘 알고 있는 사람.
- `Hash` 기반 자료구조의 동작 방식과 `hashcode()`메서드와의 관계를 이해하고 있는 사람.
- `equals()`와 `hashcode()` 메서드를 재정의하지 않았을때 발생할 수 있는 문제에 대해 이해하고 있는 사람.


🙏 **시작하기 전에**  
이 내용을 정확히 이해하려면 해시 자료구조에 대한 전반적인 이해와, 해시 충돌이라는 개념에 대해서 이해가 선제되면 좋다. 만약 잘 모르겠거나 기억이 나지 않는다면, 이에 대해서 설명해둔 글이 있어 한번 읽어보는 것을 권한다. 

👉 [해시 자료구조와 Java HashMap이 해시 충돌을 해결하는 방법](https://dongmin-sim.github.io/posts/hash-data-structure/)

`equals()` 와 `hashcode()` 메서드는 기본적으로 `java`의 `Object` 클래스에서 제공하는 메서드로, 이 메서드들은 객체의 고유한 값을 기준으로 동등성을 판단한다. 하지만 비즈니스 로직을 구현하기 위한 도메인 객체에서는 논리적 동등성을 기준으로 비교해야하는 경우가 많다. 이를 올바르게 재정의하지 않을 경우 예상치 못한 오류를 만날 수 있다.

<br>

--- 

<br>
## **1. equals()와 hashCode()란 무엇인가?**

`equals()` 메서드는 `java`에서 모든 부모 객체가 되는 `Object`의 메서드이다.

### **1.1 객체의 비교 방식: 동일성 동등성** 

일반적으로 객체를 비교하는 방식에는 크게 2가지가 있다. 
- 동일성 비교 (`identity`)
- 동등성 비교 (`equality`)

두 객체가 **물리적으로 같음**을 판단하는 것을 **동일성** 비교라 하고,   
두 객체가 **논리적으로 같음**을 판단하는 것을 **동등성** 비교라 한다.

#### **1.1.1 동일성 (identity)**
자바에서는 `==` 이라는 **비교연산자**를 통해서 **동일성 비교**를 할 수 있다.   

`==` 비교 연산자는 참조형 타입의 객체에 대해 메모리 주소를 비교하도록 동작한다. 메모리 상에서 같은 위치를 차지하고 있는지를 판단한다.

기본형 타입의 경우에는 값 자체를 비교하고, 참조형 타입의 경우 두 객체가 같은 인스턴스인지 여부를 판단한다.

#### **1.1.2 동등성 (equality)**

그렇다면 자바에서 두 객체가 **논리적으로 동일한지는** 어떻게 판단할 수 있을까?  
그전에 "논리적으로 동등하다"라는 말은 무슨말일까? 

내 생각에 **논리적으로 동등**하다는 것은, **특정 조건을 기준**으로 두 객체가 **개념적**으로, **의미적**으로 "같음"을 의미한다. 두 객체가 물리적으로 같거나 다를 수 있지만, **개념적으로 동일한 의미**를 가지는 경우를 말한다. 

**특정 조건**이 가질 수 있는 특징과 예시들을 다음과 같이 정리해봤다.
1. 물리적 차이와 무관하고
2. 공통된 추상적 속성을 가지고 있을때,

- 같은 나무로 만들어지지 않았지만, 같은 제목과 내용을 가진 2개의 책은 논리적으로 서로 같다. 
	- 같은 나무로 만들어졌어도, 다른 제목과 다른 내용이라면 두 책은 논리적으로 서로 다르다.
- "빨강"이라는 색상과 `RGB(255, 0, 0)` 은 서로 같은 색상이다. (물론 어떤 빨강이냐에 따라 다르겠지만)

|       | 동일성            | 동등성              |
| ----- | -------------- | ---------------- |
| 의미    | "물리적으로 같음"을 판단 | "논리적으로 같음"을 판단   |
| 비교 기준 | 단편적            | 복합적, 맥락에 따라 달라짐. |
| 비교 수단 | `==`           | `equals()`       |

### **1.2 equals**
일단, `equals()` 메서드는 두 객체가 서로 **논리적으로 동등한지** 비교를 하기 위한 메서드다.   

다음 예시로 `euqals()` 메서드의 필요성을 살펴보자
```java 
public class Money {  
    private BigDecimal amount;  
    private String currency;  
  
    public Money(BigDecimal amount, String currency) {  
        this.amount = amount;  
        this.currency = currency;  
    }  
}
```

위 클래스는 금액과 통화를 표현하기 위한 클래스로, 금전 데이터를 하나의 객체로 추상화하여 다루고자 설계되었다. 금액을 다루다보면 서로 같은지 다른지, 어떤 금액이 더 큰지 비교해야하는 순간이 꼭 필요하다. 

왼손과 오른손에 각각 `5,000`원씩 들려있다면 이 둘은 서로 '**같은**' 돈이라고 볼 수 있는가?   

이 돈이 만들어진 '날짜'나 만들어질때 들어간 '재료'와 같은 비교 조건들은 우리가 돈을 비교하는 본 목적과는 거리가 있다. 우리가 기대하는 것은 돈이 가진 **추상적 의미의 가치**를 비교하고 싶기 때문이다.

따라서 우리가 기대하는 현실세계에서의 답은 `yes` 일 것이다. 

이를 `Money`객체로 구현해 다음과 같이 비교한다면 어떤 결과가 나올까??
```java
public static void main(String[] args) {  
    Money moneyA = new Money(BigDecimal.valueOf(5000), "KRW");  
    Money moneyB = new Money(BigDecimal.valueOf(5000), "KRW");  
  
    System.out.println(moneyA.equals(moneyB)); // false
}
```

의도하고 기대했던 결과(`expected`)값은 `true`이지만,   
실제 비교 결과(`actual` )는 `false`이다. 

앞에서 "논리적으로 동등하다는 것은 특정 조건을 기준으로 두 객체가 개념적으로 '같음'을 의미"한다고 했다. 
`equals()`메서드는 "논리적으로 같음"을 "어떤 조건"으로 판단할지를 담당하는 메서드이다. 

결과 값이 기대와 다른 이유는 `equals()` 메서드를 오버라이드하지 않을 경우 두 객체의 참조값을 기준으로 비교를 기본동작으로 정의되어 있기 때문이다.
아래 코드는 Object.java의 equals 코드를 가져온 것이다. 코드에서 보이는 것과 같이  `==` 연산자와 동일한 방식으로 비교하게 된다.
```java
public boolean equals(Object obj) {  
    return (this == obj);  
}
```

따라서 개발자가 의도하는 객체의 올바른 비교를 위해서는 반드시 `equals()`를 "어떤 조건"으로 "논리적으로 같음"을 비교할 것인지 재정의해줘야만 한다. 

### **1.3 hashcode()**
`hashcode()` 메서드는 객체를 식별할 수 있는 식별자 값을 반환하는 메서드이다. 

이때 반환하는 정수 값은 객체의 해시 코드라고 부르며, 주로 해시 기반 자료구조에서 객체를 효율적으로 관리하기 위한 해시 함수에 사용된다. 

이 역시 `Object` 클래스에 정의된 메서드이다. 

단순히 `hashcode() == 객체 메모리 주소` 라고 암기하는 것은 바람직하지 않다. 


### **1.4 오버라이드**
(왜 재정의해야하는지에 대한 내용이 앞에 나와야 )
이 둘은 불충분하기 때문에, 개발자가 

`equals()` 는 논리적 동등성 비교를 위한 메서드이고, `hashcode()` 는 해시 기반 자료구조에서 객체를 효율적으로 관리하기 위해 필요한 메서드이다. 이 둘은 전혀 다른 역할을 하는 것 같은데 왜 이 둘을 같이 재정의해야할까?  

## 두 메서드의 관계와 발생할 수 있는 문제점 

결론부터 두 메서드는 해시 기반 컬렉션에서 객체 비교를 위한 조건을 만족시키기 위한? 메서드?

자바에서 두 메서드의 연관관계 
- 두 객체가 `equals()`로 같다고 판단되면, 반드시 동일한 해시코드를 반환
- 반대로, 두 객체가 다른 해시코드를 가질 수는 있음 


결론부터 말하자면 일관되게 오버라이드 해야함. 
그 이유는? 

해시 기반 컬렉션에서 정상적인 (개발자의 의도대로) 동작하는 것을 보장하기 위해서 이다.



### 해시 기반 컬렉션에서 문제발생 





(그림)

hashMap 동작 원리 
객체 저장시 
1. 객체의 해시 코드를 계산해서, 해시 코드 기반으로 버킷의 인덱스 위치를 결정함. 
2. 해당 버킷에 이미 객체가 존재하는 경우, -> equals 메서드를 비교
	1. 만일 동일하면 중복 객체로 판단
	2. 그렇지 않으면 새로운 객체 저장

👉 [해시 자료구조와 Java HashMap이 해시 충돌을 해결하는 방법](https://dongmin-sim.github.io/posts/hash-data-structure/) 참고

해시충돌 간략하게 설명 

서로 다른 객체에 대해 동일한 해시값을 반환하여, 저장되는 버킷의 인덱스 주소가 같아져버리는 상황을 해시충돌이라한다. 




hashCode" 를 잘못 오버라이딩하면 "HashMap" 등 hash 콜렉션의 성능이 떨어질 수가 있습니다. 어떤 케이스일 때 그럴 수 있을까요?

1. **해시 충돌 증가**: 동일한 해시 코드를 반환하는 객체들이 많아지면 성능 저하가 발생합니다.
2. **복잡한 연산 사용**: 불필요하게 복잡한 연산을 포함하면 성능 저하를 유발합니다.
3. **고르지 않은 분포**: 특정 값에 치우친 해시 코드 분포는 일부 버킷에 데이터가 몰리게 합니다.
4. **불변성 원칙 위반**: 가변 필드를 사용하여 해시 코드를 계산하면, 필드 값 변경 시 문제가 발생합니다.

- 기존 "HashMap" 의 시간복잡도는 얼마이고, "hashCode" 를 잘못 오버라이딩 했을때의 시간복잡도는 얼마일까요?

### 두 메서드를 잘못 오버라이드하면?

#### equals를 오버라이드하지 않으면?

객체간의 올바른 비교가 이루어지지 않을 수 있음. 

- **`hashCode()`만 오버라이드하고 `equals()`를 오버라이드하지 않으면**:
    
    - 같은 버킷에 저장된 논리적으로 동일한 두 객체를 구분하지 못할 수 있습니다.

#### hashcode를 오버라이드하지 않으면?

- **`equals()`만 오버라이드하고 `hashCode()`를 오버라이드하지 않으면**:
- 논리적으로 동일한 두 객체가 서로 다른 해시 코드를 가져 다른 버킷에 저장될 수 있습니다. 
- 이 경우 검색이나 중복 제거가 제대로 작동하지 않음


hashcode를 
-> 해시 충돌 가능성이 높아짐. 

해시 충돌 방식에는

## equals()와 hashCode()의 재정의 규칙

1. `equals()`가 true를 반환하는 두 객체는 반드시 같은 `hashCode()` 값을 가져야 .
    - 이유: 해시 기반 컬렉션(`HashMap`, `HashSet` 등)은 먼저 `hashCode()`를 사용해 객체를 저장할 버킷(메모리 위치)을 결정하고, 이후 동일한 버킷 내에서 `equals()`를 사용해 객체의 동등성을 확인합니다. 만약 이 규칙이 어겨지면, 논리적으로 동일한 객체임에도 불구하고 서로 다른 버킷에 저장되거나 검색되지 않을 수 있습니다[
        
2. **`equals()`가 false인 두 객체는 서로 다른 `hashCode()` 값을 가질 필요는 없습니다.**
    
    - 즉, 다른 객체가 동일한 해시 코드를 가질 수 있지만, 이는 해시 충돌(hash collision)을 초래할 수 있습니다. 충돌이 많아질수록 성능이 저하될 가능성이 있음. 
        
    
3. **동일한 객체는 항상 동일한 `hashCode()` 값을 반환해야 .**
	프로그램 실행 중에 객체의 상태가 변경되지 않았다면, 동일한 객체는 항상 같은 해시 코드를 반환해야 함

## 마무리
