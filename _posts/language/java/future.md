---
title: 
author: codongmin
date: 
categories: 
tags: 
preview:
---

## 들어가며

동시성이 필요한 경우, 조금씩 연관된 작업을 같은 CPU에서 동작하는 것. 애플리케이션 생산성을 극대화할 수 있도록 코어를 바쁘게 유지하는 것이 목표일 경우 

동시성은 단일 코어 머신에서 발생. 

Future, CompletableFuture 
flow api(publish-subscribe model)

매쉬업 애플리케이션, 다양한 웹서비스를 이용하고, 실시간으로 조합해 사용자에게 제공하거나 추가 웹 서비스를 통해 제공하는 종류의 애플리케이션을 개발하는데 필수적인 기초 모델과 툴킷을 제공. -> 리액티브 프로그래밍

병렬 스트림 반복은 명시적으로 스레드를 사용하는 것 < 높은 수준의 개념, 스트림을 이용해 스레드 사용 패턴을 추상화할 수 있음. 
스트림으로 추상화하는 것은 디자인 패턴을 적용하는 것과 비슷하지만, 대신 쓸모 없는 코드가 라이브러리 내부로 구현되면서 복잡성이 줄어든다는 장점을 가짐. 
## ExecutorService

자바 5. Executor 프레임워크와 스레드 풀을 통해, 스레드의 힘을 높은 수준으로 끌어올림. 자바프로그래머가 태스크 제출(할당)과 실행을 분리할 수 있는 기능을 제공. 

프로그래머가 태스크(Runnable, Callable)를 제공, 할당하고 스레드가 이를 실행한다.

> [!NOTE] 자바 스레드 문제
> 자바 스레드는 직접 운영체제 스레드에 접근한다. 운영체제 스레드를 만들고 종료하려면 비싼 비용을 치워야하며, 더욱이 운영체제 스레드의 숫자는 제한되어있다. 이를 초과할 경우 예상치 못한 방식으로 크래시 될 수 있다. (기존 스레드가 남아있는 상태에서 새로운 스레드를 계속 만드는 것을 자제)

ExecutorService는 태스크를 제출하고 나중에 결과를 수집할 수 있는 인터페이스를 제공. 
팩토리 메서드 `newFixedThreadPool` 로 스레드 풀 생성 가능 
워커 스레드라 불리는 nThreads를 포함하는 ExecutorService를 만들고 이들을 스레드 풀에 저장함. 스레드 풀에서 사용하지 않은 스레드로 제출된 태스크를 먼저온 순서대로 실행. 
실행이 종료되면 스레드를 풀로 반환함. 

장점 
- 하드웨어에 맞는 수의 태스크를 유지 가능. 
- 수천개의 태스크를 스레드 풀에 오버헤드 없이 할당 가능
- 큐 크기 조정, 거부 정책, 태스크 종류에 따른 우선순위등 다양한 설정 가능 

단점 
- 유휴 상태이거나, I/O를 기다리거나, 네트워크 연결을 기다리는 등 **블록**할 수 있는 태스크는 스레드 풀에 제출하지 말아야 한다. 
	- 병렬 실행 성능이 저하된다. 
- 프로그램 종료전 모든 스레드 풀을 종료하는 습관을 갖는 것이 중요하다. 

### 엄격한 포크/조인과 여유로운 포크/조인

### **엄격한 포크/조인 (Strict Fork/Join)**

- **작업 분할 및 결합 방식**: 작업이 완전히 독립적이지 않은 경우, 모든 서브작업을 반드시 기다려서 최종 결과를 도출하는 방식입니다. 즉, 모든 서브태스크가 완료되어야만 메인 태스크가 진행될 수 있습니다.
- **장점**: 결과의 정확성을 보장합니다. 모든 서브작업이 완료된 후에 메인 작업이 이어지기 때문에 각 작업 간의 데이터 의존성이 있을 때 안전하게 사용할 수 있습니다.
- **단점**: 작업 완료 시간을 기다려야 하므로 성능 상 손해가 발생할 수 있습니다. 서브태스크 중 하나라도 느리면 전체 작업이 지연될 수 있습니다.
- **적용 예**: 자바의 **ForkJoinTask**에서 `join()` 메서드를 호출하는 경우, 자식 작업이 완료될 때까지 부모 작업이 대기하는 상황.

### 2. **여유로운 포크/조인 (Relaxed Fork/Join)**

- **작업 분할 및 결합 방식**: 서브작업이 완전히 독립적일 때 각 작업이 개별적으로 실행되고, 각 작업의 완료 상태에 관계없이 다음 작업이 진행될 수 있는 방식입니다. 즉, 하나의 작업이 완료되기 전에 다른 작업이 수행될 수 있습니다.
- **장점**: 병렬성 극대화. 작업 간의 의존성이 없을 경우, 각 서브작업이 독립적으로 진행되어 더 빠른 처리가 가능합니다.
- **단점**: 작업 간 의존성이 있는 경우에는 문제를 일으킬 수 있습니다. 서브작업의 결과를 기다리지 않고 다른 작업이 진행되기 때문에 데이터 일관성이 깨질 수 있습니다.
- **적용 예**: 자바의 **CompletableFuture**에서 각 태스크가 독립적으로 실행되고, `thenCombine()`이나 `thenAccept()`와 같은 메서드를 통해 각 작업을 이어가는 방식.

### 비동기 메서드 
사용자의 메서드 호출에 의해 스레드가 생성되고, 메서드를 벗어나 계속 실행되는 메서드 

비동기 메서드를 사용할 때 주의 사항 
- 스레드 실행은 메서드를 호출한 다음의 코드와 동시에 실행되므로 데이터 경쟁 문제를 일으키지 않도록 주의
- 기존 실행 중이던 스레드가 종료되지 않은 상황에서 자바의 main() 메서드가 반환하면 ?
	- 애플리케이션을 종료하지 못하고 모든 스레드가 실행을 끝낼때까지 기다림. 
	- 애플리케이션 종료를 방해하는 스레드를 강제종료, 애플리케이션 종료 

애플리케이션 크래시가 발생할 수 있고, 디스크 쓰기 I/O작업을 시도하는 작업을 중단했을때, 데이터 일관성이 파괴될 가능성 있음. 애플리케이션에서 만든 모든 스레드를 추적하고, 스레드 풀을 포함한 모든 스레드를 종료하는 것이 좋음.

`setDeamon` 메서드로 데모과 비데몬으로 구분가능 
- 데몬 스레드는 애플리케이션이 종료될때, 강제 종료됨(강제 종료되어도 괜찮은 작업에 사용)
- `main` 메서드는 모든 비 데몬 스레드가 종료될때까지 프로그램을 종료하지 않고 기다림.

## 마무리
